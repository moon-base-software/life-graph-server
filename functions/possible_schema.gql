# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

"""Information about the creation of a node"""
scalar Creation

enum BaseType {
    FLOAT
    INT
    STRING
    BOOLEAN
    GEO_REFERENCE
    TEMPORAL_REFERENCE
}

type GeoPoint {
    latitude: Float
    longitude: Float
}

type GeoPath {
    points: [GeoPoints]
}

union GeoReference = GeoPoint | GeoPath

#
#type GeoMeasurement {
#    reference: GeoReference
#    accuracy: Floar // How to correct define the units
#}
#

type TemporalReference {
    granularity: TemporalGranularity
    year: Int
    month: Int
    weekNumber: Int
    day: Int
    hour: Int
    minute: Int
    second: Int
    partialSeconds: Float
}

enum TemporalGranularity {
    MILLENIUM
    CENTURY
    DECADE
    YEAR
    HALF_YEAR
    QUARTER_YEAR
    MONTH
    FOUR_WEEK
    TWO_WEEK
    WEEK
    DAY
    HALF_DAY
    HOUR
    HALF_HOUR
    QUARTER_HOUR
    TEN_MINUTE
    FIVE_MINUTE
    MINUTE
    HALF_MINUTE
    QUARTER_MINUTE
    TEN_SECOND
    FIVE_SECOND
    SECOND
    MILLI_SECOND
    NANO_SECOND
}

interface Series {
    id: ID!
    name: String!
    unit: String
}

input SeriesInput {
    name: String!
    unit: String
}

type IntSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

type FloatSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

type StringSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

type BooleanSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

type GeoSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

type TemporalSeries implements Series {
    id: ID!
    name: String!
    unit: String
}

interface SeriesValue {
    node: Node!
    series: Series!
}

type IntSeriesValue implements SeriesValue {
    series: IntSeries!
    intValue: Int!
}

type FloatSeriesValue implements SeriesValue {
    series: FloatSeries!
    floatValue: Float!
}

type StringSeriesValue implements SeriesValue {
    series: StringSeries!
    stringValue: String!
}

type BooleanSeriesValue implements SeriesValue {
    series: BooleanSeries!
    boolValue: Boolean!
}

type GeoSeriesValue implements SeriesValue {
    series: GeoSeries!
    geoValue: GeoReference!
}

type TemporalSeriesValue implements SeriesValue {
    series: TemporalSeries!
    temporalValue: TemporalReference!
}

interface Node {
    id: ID!
    type: NodeType!
    creation: Creation!
    seriesValues: [SeriesValue!]
    outgoingConnections: [Connection!]
    incomingConnections: [Connection!]
}

type NodeType {
    id: ID!
    name: String!
}

type GenericNode {
    id: ID!
    type: NodeType!
    creation: Creation!
    seriesValues: [SeriesValue!]
    outgoingConnections: [Connection!]
    incomingConnections: [Connection!]
}

type Connection {
    id: ID!
    from: Node!
    to: Node!
    creation: Creation!
}

union GraphObjects = Node | Connection

type Mutation {
    createNode(): Node!
    createConnection(from: Node!, to: Node!): Connection!

    createIntSeries(series: SeriesInput!): IntSeries!
    createFloatSeries(series: SeriesInput!): FloatSeries!
    createStringSeries(series: SeriesInput!): StringSeries!
    createBooleanbSeries(series: SeriesInput!): BooleanSeries!
    createGeoSeries(series: SeriesInput!): GeoSeries!
    createTemporalSeries(series: SeriesInput!): TemporalSeries!
    
    setIntSeriesValueToNode(node: Node!, series: IntSeries!): IntSeriesValue!
    setFloatSeriesValeToNode(node: Node!, series: FloatSeries!): FloatSeriesValue!
    setStringSeriesValueToNode(node: Node!, series: StringSeries!): StringSeriesValue!
    setBoolSeriesValueToNode(node: Node!, series: BooleanSeries!): BooleanSeriesValue!
    setGeoSeriesValueToNode(node: Node!, series: GeoSeries!): GeoSeriesValue!
    setTemporalSeriesValueToNode(node: Node!, series: TemporalSeries!): TemporalSeriesValue!

    removeIntSeriesValueFromNode(ode: Node!, series: IntSeries!): Boolean!
    removeFloatSeriesValueFromNode(node: Node!, series: FloatSeries!): Boolean!
    removeStringSeriesValueFromNode(node: Node!, series: StringSeries!): Boolean!
    removeBoolSeriesValueFromNode(node: Node!, series: BooleanSeries!): Boolean!
    removeGeoSeriesValueFromNode(node: Node!, series: GeoSeries!): Boolean!
    removeTemporalSeriesValueFromNode(node: Node!, series: TemporalSeries!): Boolean!

    # Assumption, you never need more than one value per series, if you think you do, you likely should create a new object.
    
    deleteNode(id: ID!): Boolean!
    deleteConnection(id: ID!): Boolean!

    deleteIntSeries(id: ID!): Boolean!
    deleteFloatSeries(id: ID!): Boolean!
    deleteStringSeries(id: ID!): Boolean!
    deleteBooleanbSeries(id: ID!): Boolean!
    deleteGeoSeries(id: ID!): Boolean!
    deleteTemporalSeries(id: ID!): Boolean!
}

# If it has an ID is has reference symantics, if not, it has value semantics.
# Do we need the concept of SpaceTime that combines temporal and GeoCoordinates, so we can treat them as one base type?


type Query {
    numberOfNodes: Int!
    numberOfConnections: Int!

    nodeByID(id: ID): Node
    connectionByID(id: ID): Connection
    seriesByID(id: ID): Series

    nodesByType(type: NodeType): [Node!]

    allNodes: [Node!]
    allConnections: [Connection!]
    allSeries: [Series!]
    allIntSeries: [IntSeries!] // Do the rest

    connectingPath(fromNode: Node!, toNode: Node!, directional: Boolean = false): [Node!]
}
